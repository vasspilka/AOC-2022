# Advent of Code

```elixir
Mix.install([
  {:httpoison, "~> 1.8"}
])
```

## Setup

```elixir
defmodule AOC do
  def get_day(num) do
    {:ok, resp} =
      HTTPoison.get("https://adventofcode.com/2022/day/#{num}/input",
        cookie: System.fetch_env!("LB_COOKIE")
      )

    resp.body
  end
end
```

## Day 1

```elixir
input = AOC.get_day(1)

elfs =
  input
  |> String.split("\n\n")
  |> Enum.map(fn elf ->
    elf
    |> String.split("\n")
    |> Enum.reject(&(&1 == ""))
    |> Enum.map(&String.to_integer/1)
    |> Enum.sum()
  end)
  |> Enum.sort(:desc)

max = List.first(elfs)

top3 =
  elfs
  |> Enum.take(3)
  |> Enum.sum()
```

## Day 2

```elixir
input = AOC.get_day(2)

# Part 1

points_map = %{
  "X" => 1,
  "Y" => 2,
  "Z" => 3,
  :loss => 0,
  :draw => 3,
  :win => 6
}

game_result = fn
  "A", "X" -> :draw
  "B", "X" -> :loss
  "C", "X" -> :win
  "A", "Y" -> :win
  "B", "Y" -> :draw
  "C", "Y" -> :loss
  "A", "Z" -> :loss
  "B", "Z" -> :win
  "C", "Z" -> :draw
end

input
|> String.split("\n", trim: true)
|> Enum.map(fn <<p1_choice::binary-size(1), " ", p2_choice::binary>> ->
  points_map[game_result.(p1_choice, p2_choice)] + points_map[p2_choice]
end)
|> Enum.sum()
```

```elixir
# Part 2

game_result = fn
  # {rock -> scissors, :loss}
  "A", "X" -> 3
  # {paper -> rock, :loss}
  "B", "X" -> 1
  # {rock -> paper, :loss}
  "C", "X" -> 2
  # {rock -> rock, :draw}
  "A", "Y" -> 4
  # {paper -> paper, :draw}
  "B", "Y" -> 5
  # {scissors -> scissors, :draw}
  "C", "Y" -> 6
  # {rock -> paper, :win}
  "A", "Z" -> 8
  # {paper -> scissors, :win}
  "B", "Z" -> 9
  # {scissors -> rock, :win}
  "C", "Z" -> 7
end

input
|> String.split("\n")
|> Enum.reject(&(&1 == ""))
|> Enum.map(fn <<p1_choice::binary-size(1), " ", p2_choice::binary>> ->
  game_result.(p1_choice, p2_choice)
end)
|> Enum.sum()
```
## Day 3

```elixir
input = AOC.get_day(3)

score = fn
  <<lower::utf8>> when lower in ?a..?z ->
    lower - ?a + 1

  <<upper::utf8>> when upper in ?A..?Z ->
    upper - ?A + 27
end

# Part 1
input
|> String.split("\n", trim: true)
|> Enum.map(fn str ->
  size = String.length(str)

  [p1, p2] =
    String.split_at(str, div(size, 2))
    |> Tuple.to_list()
    |> Enum.map(&String.split(&1, "", trim: true))

  tmp_list = p1 -- p2
  # Sometimes we get the same result twice as ["X", "X"]
  [common_item | _] = p1 -- tmp_list

  score.(common_item)
end)
|> Enum.sum()
```

```elixir
# Part 2
input
|> String.split("\n", trim: true)
|> Enum.chunk_every(3)
|> Enum.map(fn strings ->
  [l1, l2, l3] = Enum.map(strings, &String.split(&1, "", trim: true))

  Enum.find(l1, fn char ->
    Enum.member?(l2, char) && Enum.member?(l3, char)
  end)
  |> score.()
end)
|> Enum.sum()
```
